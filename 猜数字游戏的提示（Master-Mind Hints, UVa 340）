/*
猜数字游戏的提示（Master-Mind Hints, UVa 340）
实现一个经典"猜数字"游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确
（A），有多少数字在两个序列都出现过但位置不对（B）。
输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干
猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。
样例输入：
4
1 3 5 5
1 1 2 3
4 3 3 5
6 5 5 1
6 1 3 5
1 3 5 5
0 0 0 0
10
1 2 2 2 4 5 6 6 6 9
1 2 3 4 5 6 7 8 9 1
1 1 2 2 3 3 4 4 5 5
1 2 1 3 1 5 1 6 1 9
1 2 2 5 5 5 6 6 6 7
0 0 0 0 0 0 0 0 0 0
0
样例输出：
Game 1:
(1,1)
(2,0)
(1,2)
(1,2)
(4,0)
Game 2:
(2,4)
(3,2)
(5,0)
(7,0)
*/
#include<stdio.h>
#define maxn 1010

int main()
{
	int n,a[maxn],b[maxn];
	int kase = 0;
	while(scanf("%d",&n)==1 && n)//n=0时输入结束 
	{
		printf("Game %d:\n",++kase);
		int i;
		for(i=0;i<n;i++)
			scanf("%d",&a[i]);
		
		for(;;)
		{
			int A=0,B=0;
			int i;
			for(i=0;i<n;i++)
			{
				scanf("%d",&b[i]);
				if(a[i] == b[i]) A++;
			}
			
			if(b[0]==0) break;//正常的猜测序列不会有0，所以只判断第一个数是否为0 
			int d;
			for(d=1;d<=9;d++)
			{
				int c1=0,c2=0;
				int i;
				for(i=0;i<n;i++)
				{
					if(a[i] == d) c1++;
					if(b[i] == d) c2++;
				}
				if(c1<c2) B += c1;
				else B += c2;
			}
		    printf("   (%d,%d)\n",A,B-A);
		}
	}
	return 0;
 } 
